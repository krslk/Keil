C51 COMPILER V9.01   MAIN                                                                  10/09/2024 19:26:59 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\object\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\main.c BROWSE DEBUG OBJECTEXTEND PRINT(.\listing\main.lst) OBJECT(.
                    -\object\main.obj)

line level    source

   1          #include <reg52.h>
   2          
   3          typedef unsigned char uchar_8;
   4          typedef unsigned int uint_16;
   5          typedef int int_16;
   6          
   7          #ifndef LED_CONTROLLER
   8          #define LED_CONTROLLER
   9          int_16 sec_ns_step = 23;
  10          int_16 sec_we_step = 20;
  11          int_16 sec_ns = 0;
  12          int_16 sec_we = 0;
  13          sbit led_green_ns = P1 ^ 4;
  14          sbit led_yellow_ns = P1 ^ 5;
  15          sbit led_red_ns = P1 ^ 6;
  16          sbit led_green_we = P2 ^ 6;
  17          sbit led_yellow_we = P2 ^ 5;
  18          sbit led_red_we = P2 ^ 4;
  19          
  20          #endif
  21          
  22          #ifndef LED_SCREEN
  23          #define LED_SCREEN P0
  24          uint_16 num_code[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
  25          sbit cn_we_dec = P2 ^ 0; // 东西方向数字十位
  26          sbit cn_we_one = P2 ^ 1; // 东西方向数字个位
  27          sbit cn_ns_dec = P2 ^ 2; // 南北方向数字十位
  28          sbit cn_ns_one = P2 ^ 3; // 南北方向数字个位
  29          #endif
  30          
  31          #ifndef KEY_CONTROLLER
  32          #define KEY_CONTROLLER
  33          
  34          #define KEY_START_PRESS 1
  35          #define KEY_STOP_PRESS 2
  36          #define KEY_ADD_TIME_PRESS 3
  37          #define KEY_SUB_TIME_PRESS 4
  38          #define NO_PRESS 0
  39          
  40          sbit KEY_START = P1 ^ 0;
  41          sbit KEY_STOP = P1 ^ 1;
  42          sbit KEY_ADD_TIME = P1 ^ 2;
  43          sbit KEY_SUB_TIME = P1 ^ 3;
  44          
  45          #endif
  46          
  47          // 函数声明
  48          void delay_us(uint_16 us);
  49          void time0_init(void);
  50          void display(void);
  51          void screen_init(void);
  52          void init(void);
  53          void led_controller(void);
  54          void key_controller(void);
C51 COMPILER V9.01   MAIN                                                                  10/09/2024 19:26:59 PAGE 2   

  55          void swap(int_16 *a, int_16 *b);
  56          
  57          uchar_8 key_scan(void);
  58          
  59          void main()
  60          {
  61   1          init();
  62   1          while (1)
  63   1          {
  64   2              key_controller();
  65   2              display();
  66   2          }
  67   1      }
  68          
  69          /**
  70           *
  71           * *******************************************************************************************************
             -*
  72           */
  73          
  74          void init(void)
  75          {
  76   1          screen_init();
  77   1          time0_init();
  78   1      }
  79          
  80          void screen_init(void)
  81          {
  82   1          sec_ns = sec_ns_step;
  83   1          sec_we = sec_we_step;
  84   1      }
  85          
  86          void time0_init(void)
  87          {
  88   1          TMOD |= 0X01; // 选择为定时器 0 模式，工作方式 1
  89   1          TH0 = 0XFC;   // 给定时器赋初值，定时 1ms
  90   1          TL0 = 0X18;
  91   1          ET0 = 1; // 打开定时器 0 中断允许
  92   1          EA = 1;  // 打开总中断
  93   1          TR0 = 0; // 关闭定时器
  94   1      }
  95          
  96          void key_controller(void)
  97          {
  98   1          switch (key_scan())
  99   1          {
 100   2          case KEY_START_PRESS:
 101   2              TR0 = 1;
 102   2              break;
 103   2          case KEY_STOP_PRESS:
 104   2              TR0 = 0;
 105   2              break;
 106   2          case KEY_ADD_TIME_PRESS:
 107   2              sec_ns_step += 5;
 108   2              sec_we_step += 5;
 109   2              sec_ns += 5;
 110   2              sec_we += 5;
 111   2              break;
 112   2          case KEY_SUB_TIME_PRESS:
 113   2              if (sec_ns_step > 15 && sec_we_step > 15)
 114   2              {
 115   3                  sec_ns_step -= 5;
C51 COMPILER V9.01   MAIN                                                                  10/09/2024 19:26:59 PAGE 3   

 116   3                  sec_we_step -= 5;
 117   3              }
 118   2              break;
 119   2          }
 120   1      }
 121          
 122          void led_controller(void)
 123          {
 124   1          if ((sec_ns_step > sec_we_step ? sec_ns : sec_we) > 3)
 125   1          {
 126   2              if (sec_ns_step > sec_we_step)
 127   2              {
 128   3                  led_red_ns = 1;
 129   3                  led_green_ns = 0;
 130   3                  led_yellow_ns = 0;
 131   3                  led_red_we = 0;
 132   3                  led_green_we = 1;
 133   3                  led_yellow_we = 0;
 134   3              }
 135   2              else
 136   2              {
 137   3                  led_red_ns = 0;
 138   3                  led_green_ns = 1;
 139   3                  led_yellow_ns = 0;
 140   3                  led_red_we = 1;
 141   3                  led_green_we = 0;
 142   3                  led_yellow_we = 0;
 143   3              }
 144   2          }
 145   1          else
 146   1          {
 147   2              if (sec_ns_step > sec_we_step)
 148   2              {
 149   3                  led_red_ns = 1;
 150   3                  led_green_ns = 0;
 151   3                  led_yellow_ns = 0;
 152   3                  led_red_we = 0;
 153   3                  led_green_we = 0;
 154   3                  led_yellow_we = 1;
 155   3              }
 156   2              else
 157   2              {
 158   3                  led_red_ns = 0;
 159   3                  led_green_ns = 0;
 160   3                  led_yellow_ns = 1;
 161   3                  led_red_we = 1;
 162   3                  led_green_we = 0;
 163   3                  led_yellow_we = 0;
 164   3              }
 165   2          }
 166   1      }
 167          
 168          void time0() interrupt 1
 169          {
 170   1          static uint_16 count_ms = 0;
 171   1          TH0 = 0XFC;
 172   1          TL0 = 0X18;
 173   1          count_ms++;
 174   1          if (count_ms == 1000)
 175   1          {
 176   2              count_ms = 0;
 177   2              sec_we--;
C51 COMPILER V9.01   MAIN                                                                  10/09/2024 19:26:59 PAGE 4   

 178   2              sec_ns--;
 179   2              if ((sec_ns_step > sec_we_step ? sec_we : sec_ns) == 0)
 180   2              {
 181   3                  if ((sec_ns_step > sec_we_step ? sec_ns : sec_we) == 3)
 182   3                  {
 183   4                      if (sec_ns_step > sec_we_step)
 184   4                      {
 185   5                          sec_we = 3;
 186   5                      }
 187   4                      else
 188   4                      {
 189   5                          sec_ns = 3;
 190   5                      }
 191   4                  }
 192   3                  else
 193   3                  {
 194   4                      swap(&sec_ns_step, &sec_we_step);
 195   4                      screen_init();
 196   4                  }
 197   3              }
 198   2              led_controller();
 199   2          }
 200   1      }
 201          
 202          void display(void)
 203          {
 204   1          cn_we_dec = 1;
 205   1          cn_we_one = 0;
 206   1          cn_ns_dec = 0;
 207   1          cn_ns_one = 0;
 208   1          LED_SCREEN = ~num_code[sec_we / 10];
 209   1          delay_us(50);
 210   1          LED_SCREEN = 0xff;
 211   1          cn_we_dec = 0;
 212   1          cn_we_one = 1;
 213   1          cn_ns_dec = 0;
 214   1          cn_ns_one = 0;
 215   1          LED_SCREEN = ~num_code[sec_we % 10];
 216   1          delay_us(50);
 217   1          LED_SCREEN = 0xff;
 218   1          cn_we_dec = 0;
 219   1          cn_we_one = 0;
 220   1          cn_ns_dec = 1;
 221   1          cn_ns_one = 0;
 222   1          LED_SCREEN = ~num_code[sec_ns / 10];
 223   1          delay_us(50);
 224   1          LED_SCREEN = 0xff;
 225   1          cn_we_dec = 0;
 226   1          cn_we_one = 0;
 227   1          cn_ns_dec = 0;
 228   1          cn_ns_one = 1;
 229   1          LED_SCREEN = ~num_code[sec_ns % 10];
 230   1          delay_us(50);
 231   1          LED_SCREEN = 0xff;
 232   1      }
 233          
 234          uchar_8 key_scan(void)
 235          {
 236   1          static uchar_8 tag = 0;
 237   1          if (tag == 0 && (KEY_START == 0 || KEY_STOP == 0 || KEY_ADD_TIME == 0 || KEY_SUB_TIME == 0))
 238   1          {
 239   2              tag = 1;
C51 COMPILER V9.01   MAIN                                                                  10/09/2024 19:26:59 PAGE 5   

 240   2              display();
 241   2              if (KEY_START == 0)
 242   2              {
 243   3                  return KEY_START_PRESS;
 244   3              }
 245   2              else if (KEY_STOP == 0)
 246   2              {
 247   3                  return KEY_STOP_PRESS;
 248   3              }
 249   2              else if (KEY_ADD_TIME == 0)
 250   2              {
 251   3                  return KEY_ADD_TIME_PRESS;
 252   3              }
 253   2              else if (KEY_SUB_TIME == 0)
 254   2              {
 255   3                  return KEY_SUB_TIME_PRESS;
 256   3              }
 257   2          }
 258   1          else if (KEY_START == 1 && KEY_STOP == 1 && KEY_ADD_TIME == 1 && KEY_SUB_TIME == 1)
 259   1          {
 260   2              tag = 0;
 261   2          }
 262   1          return NO_PRESS;
 263   1      }
 264          
 265          void delay_us(uint_16 us)
 266          {
 267   1          while (us--)
 268   1              ;
 269   1      }
 270          
 271          void swap(int_16 *a, int_16 *b)
 272          {
 273   1          int_16 buf = *a;
 274   1          *a = *b;
 275   1          *b = buf;
 276   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    742    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
